// Copyright 2024 The Jumpstarter Authors

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: jumpstarter/v1/jumpstarter.proto

package jumpstarterv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ControllerService_Register_FullMethodName     = "/jumpstarter.v1.ControllerService/Register"
	ControllerService_Unregister_FullMethodName   = "/jumpstarter.v1.ControllerService/Unregister"
	ControllerService_ReportStatus_FullMethodName = "/jumpstarter.v1.ControllerService/ReportStatus"
	ControllerService_Listen_FullMethodName       = "/jumpstarter.v1.ControllerService/Listen"
	ControllerService_Status_FullMethodName       = "/jumpstarter.v1.ControllerService/Status"
	ControllerService_Dial_FullMethodName         = "/jumpstarter.v1.ControllerService/Dial"
	ControllerService_AuditStream_FullMethodName  = "/jumpstarter.v1.ControllerService/AuditStream"
	ControllerService_GetLease_FullMethodName     = "/jumpstarter.v1.ControllerService/GetLease"
	ControllerService_RequestLease_FullMethodName = "/jumpstarter.v1.ControllerService/RequestLease"
	ControllerService_ReleaseLease_FullMethodName = "/jumpstarter.v1.ControllerService/ReleaseLease"
	ControllerService_ListLeases_FullMethodName   = "/jumpstarter.v1.ControllerService/ListLeases"
)

// ControllerServiceClient is the client API for ControllerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service where a exporter can connect to make itself available
type ControllerServiceClient interface {
	// Exporter registration
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	// Exporter disconnection
	// Disconnecting with bye will invalidate any existing router tokens
	// we will eventually have a mechanism to tell the router this token
	// has been invalidated
	Unregister(ctx context.Context, in *UnregisterRequest, opts ...grpc.CallOption) (*UnregisterResponse, error)
	// Exporter status report
	// Allows exporters to report their own status to the controller
	ReportStatus(ctx context.Context, in *ReportStatusRequest, opts ...grpc.CallOption) (*ReportStatusResponse, error)
	// Exporter listening
	// Returns stream tokens for accepting incoming client connections
	Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListenResponse], error)
	// Exporter status
	// Returns lease status for the exporter
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusResponse], error)
	// Client connecting
	// Returns stream token for connecting to the desired exporter
	// Leases are checked before token issuance
	Dial(ctx context.Context, in *DialRequest, opts ...grpc.CallOption) (*DialResponse, error)
	// Audit events from the exporters
	// audit events are used to track the exporter's activity
	AuditStream(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[AuditStreamRequest, emptypb.Empty], error)
	// Get Lease
	GetLease(ctx context.Context, in *GetLeaseRequest, opts ...grpc.CallOption) (*GetLeaseResponse, error)
	// Request Lease
	RequestLease(ctx context.Context, in *RequestLeaseRequest, opts ...grpc.CallOption) (*RequestLeaseResponse, error)
	// Release Lease
	ReleaseLease(ctx context.Context, in *ReleaseLeaseRequest, opts ...grpc.CallOption) (*ReleaseLeaseResponse, error)
	// List Leases
	ListLeases(ctx context.Context, in *ListLeasesRequest, opts ...grpc.CallOption) (*ListLeasesResponse, error)
}

type controllerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerServiceClient(cc grpc.ClientConnInterface) ControllerServiceClient {
	return &controllerServiceClient{cc}
}

func (c *controllerServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, ControllerService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) Unregister(ctx context.Context, in *UnregisterRequest, opts ...grpc.CallOption) (*UnregisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterResponse)
	err := c.cc.Invoke(ctx, ControllerService_Unregister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) ReportStatus(ctx context.Context, in *ReportStatusRequest, opts ...grpc.CallOption) (*ReportStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportStatusResponse)
	err := c.cc.Invoke(ctx, ControllerService_ReportStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListenResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ControllerService_ServiceDesc.Streams[0], ControllerService_Listen_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListenRequest, ListenResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_ListenClient = grpc.ServerStreamingClient[ListenResponse]

func (c *controllerServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StatusResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ControllerService_ServiceDesc.Streams[1], ControllerService_Status_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StatusRequest, StatusResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_StatusClient = grpc.ServerStreamingClient[StatusResponse]

func (c *controllerServiceClient) Dial(ctx context.Context, in *DialRequest, opts ...grpc.CallOption) (*DialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DialResponse)
	err := c.cc.Invoke(ctx, ControllerService_Dial_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) AuditStream(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[AuditStreamRequest, emptypb.Empty], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ControllerService_ServiceDesc.Streams[2], ControllerService_AuditStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AuditStreamRequest, emptypb.Empty]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_AuditStreamClient = grpc.ClientStreamingClient[AuditStreamRequest, emptypb.Empty]

func (c *controllerServiceClient) GetLease(ctx context.Context, in *GetLeaseRequest, opts ...grpc.CallOption) (*GetLeaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLeaseResponse)
	err := c.cc.Invoke(ctx, ControllerService_GetLease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) RequestLease(ctx context.Context, in *RequestLeaseRequest, opts ...grpc.CallOption) (*RequestLeaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestLeaseResponse)
	err := c.cc.Invoke(ctx, ControllerService_RequestLease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) ReleaseLease(ctx context.Context, in *ReleaseLeaseRequest, opts ...grpc.CallOption) (*ReleaseLeaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseLeaseResponse)
	err := c.cc.Invoke(ctx, ControllerService_ReleaseLease_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) ListLeases(ctx context.Context, in *ListLeasesRequest, opts ...grpc.CallOption) (*ListLeasesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLeasesResponse)
	err := c.cc.Invoke(ctx, ControllerService_ListLeases_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServiceServer is the server API for ControllerService service.
// All implementations must embed UnimplementedControllerServiceServer
// for forward compatibility.
//
// A service where a exporter can connect to make itself available
type ControllerServiceServer interface {
	// Exporter registration
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	// Exporter disconnection
	// Disconnecting with bye will invalidate any existing router tokens
	// we will eventually have a mechanism to tell the router this token
	// has been invalidated
	Unregister(context.Context, *UnregisterRequest) (*UnregisterResponse, error)
	// Exporter status report
	// Allows exporters to report their own status to the controller
	ReportStatus(context.Context, *ReportStatusRequest) (*ReportStatusResponse, error)
	// Exporter listening
	// Returns stream tokens for accepting incoming client connections
	Listen(*ListenRequest, grpc.ServerStreamingServer[ListenResponse]) error
	// Exporter status
	// Returns lease status for the exporter
	Status(*StatusRequest, grpc.ServerStreamingServer[StatusResponse]) error
	// Client connecting
	// Returns stream token for connecting to the desired exporter
	// Leases are checked before token issuance
	Dial(context.Context, *DialRequest) (*DialResponse, error)
	// Audit events from the exporters
	// audit events are used to track the exporter's activity
	AuditStream(grpc.ClientStreamingServer[AuditStreamRequest, emptypb.Empty]) error
	// Get Lease
	GetLease(context.Context, *GetLeaseRequest) (*GetLeaseResponse, error)
	// Request Lease
	RequestLease(context.Context, *RequestLeaseRequest) (*RequestLeaseResponse, error)
	// Release Lease
	ReleaseLease(context.Context, *ReleaseLeaseRequest) (*ReleaseLeaseResponse, error)
	// List Leases
	ListLeases(context.Context, *ListLeasesRequest) (*ListLeasesResponse, error)
	mustEmbedUnimplementedControllerServiceServer()
}

// UnimplementedControllerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedControllerServiceServer struct{}

func (UnimplementedControllerServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedControllerServiceServer) Unregister(context.Context, *UnregisterRequest) (*UnregisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Unregister not implemented")
}
func (UnimplementedControllerServiceServer) ReportStatus(context.Context, *ReportStatusRequest) (*ReportStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportStatus not implemented")
}
func (UnimplementedControllerServiceServer) Listen(*ListenRequest, grpc.ServerStreamingServer[ListenResponse]) error {
	return status.Error(codes.Unimplemented, "method Listen not implemented")
}
func (UnimplementedControllerServiceServer) Status(*StatusRequest, grpc.ServerStreamingServer[StatusResponse]) error {
	return status.Error(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedControllerServiceServer) Dial(context.Context, *DialRequest) (*DialResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Dial not implemented")
}
func (UnimplementedControllerServiceServer) AuditStream(grpc.ClientStreamingServer[AuditStreamRequest, emptypb.Empty]) error {
	return status.Error(codes.Unimplemented, "method AuditStream not implemented")
}
func (UnimplementedControllerServiceServer) GetLease(context.Context, *GetLeaseRequest) (*GetLeaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLease not implemented")
}
func (UnimplementedControllerServiceServer) RequestLease(context.Context, *RequestLeaseRequest) (*RequestLeaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestLease not implemented")
}
func (UnimplementedControllerServiceServer) ReleaseLease(context.Context, *ReleaseLeaseRequest) (*ReleaseLeaseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReleaseLease not implemented")
}
func (UnimplementedControllerServiceServer) ListLeases(context.Context, *ListLeasesRequest) (*ListLeasesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLeases not implemented")
}
func (UnimplementedControllerServiceServer) mustEmbedUnimplementedControllerServiceServer() {}
func (UnimplementedControllerServiceServer) testEmbeddedByValue()                           {}

// UnsafeControllerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllerServiceServer will
// result in compilation errors.
type UnsafeControllerServiceServer interface {
	mustEmbedUnimplementedControllerServiceServer()
}

func RegisterControllerServiceServer(s grpc.ServiceRegistrar, srv ControllerServiceServer) {
	// If the following call panics, it indicates UnimplementedControllerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ControllerService_ServiceDesc, srv)
}

func _ControllerService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_Unregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).Unregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_Unregister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).Unregister(ctx, req.(*UnregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_ReportStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).ReportStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_ReportStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).ReportStatus(ctx, req.(*ReportStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerServiceServer).Listen(m, &grpc.GenericServerStream[ListenRequest, ListenResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_ListenServer = grpc.ServerStreamingServer[ListenResponse]

func _ControllerService_Status_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ControllerServiceServer).Status(m, &grpc.GenericServerStream[StatusRequest, StatusResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_StatusServer = grpc.ServerStreamingServer[StatusResponse]

func _ControllerService_Dial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).Dial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_Dial_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).Dial(ctx, req.(*DialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_AuditStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ControllerServiceServer).AuditStream(&grpc.GenericServerStream[AuditStreamRequest, emptypb.Empty]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ControllerService_AuditStreamServer = grpc.ClientStreamingServer[AuditStreamRequest, emptypb.Empty]

func _ControllerService_GetLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).GetLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_GetLease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).GetLease(ctx, req.(*GetLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_RequestLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).RequestLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_RequestLease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).RequestLease(ctx, req.(*RequestLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_ReleaseLease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseLeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).ReleaseLease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_ReleaseLease_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).ReleaseLease(ctx, req.(*ReleaseLeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_ListLeases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLeasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).ListLeases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllerService_ListLeases_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).ListLeases(ctx, req.(*ListLeasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ControllerService_ServiceDesc is the grpc.ServiceDesc for ControllerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControllerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jumpstarter.v1.ControllerService",
	HandlerType: (*ControllerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _ControllerService_Register_Handler,
		},
		{
			MethodName: "Unregister",
			Handler:    _ControllerService_Unregister_Handler,
		},
		{
			MethodName: "ReportStatus",
			Handler:    _ControllerService_ReportStatus_Handler,
		},
		{
			MethodName: "Dial",
			Handler:    _ControllerService_Dial_Handler,
		},
		{
			MethodName: "GetLease",
			Handler:    _ControllerService_GetLease_Handler,
		},
		{
			MethodName: "RequestLease",
			Handler:    _ControllerService_RequestLease_Handler,
		},
		{
			MethodName: "ReleaseLease",
			Handler:    _ControllerService_ReleaseLease_Handler,
		},
		{
			MethodName: "ListLeases",
			Handler:    _ControllerService_ListLeases_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Listen",
			Handler:       _ControllerService_Listen_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Status",
			Handler:       _ControllerService_Status_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AuditStream",
			Handler:       _ControllerService_AuditStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "jumpstarter/v1/jumpstarter.proto",
}

const (
	ExporterService_GetReport_FullMethodName           = "/jumpstarter.v1.ExporterService/GetReport"
	ExporterService_DriverCall_FullMethodName          = "/jumpstarter.v1.ExporterService/DriverCall"
	ExporterService_StreamingDriverCall_FullMethodName = "/jumpstarter.v1.ExporterService/StreamingDriverCall"
	ExporterService_LogStream_FullMethodName           = "/jumpstarter.v1.ExporterService/LogStream"
	ExporterService_Reset_FullMethodName               = "/jumpstarter.v1.ExporterService/Reset"
	ExporterService_GetStatus_FullMethodName           = "/jumpstarter.v1.ExporterService/GetStatus"
	ExporterService_EndSession_FullMethodName          = "/jumpstarter.v1.ExporterService/EndSession"
)

// ExporterServiceClient is the client API for ExporterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// A service a exporter can share locally to be used without a server
// Channel/Call credentials are used to authenticate the client, and routing to the right exporter
type ExporterServiceClient interface {
	// Exporter registration
	GetReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetReportResponse, error)
	DriverCall(ctx context.Context, in *DriverCallRequest, opts ...grpc.CallOption) (*DriverCallResponse, error)
	StreamingDriverCall(ctx context.Context, in *StreamingDriverCallRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingDriverCallResponse], error)
	LogStream(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogStreamResponse], error)
	Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error)
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// End the current session, triggering the afterLease hook
	// The client should keep the connection open to receive hook logs via LogStream
	// Returns after the afterLease hook completes
	EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error)
}

type exporterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExporterServiceClient(cc grpc.ClientConnInterface) ExporterServiceClient {
	return &exporterServiceClient{cc}
}

func (c *exporterServiceClient) GetReport(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetReportResponse)
	err := c.cc.Invoke(ctx, ExporterService_GetReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exporterServiceClient) DriverCall(ctx context.Context, in *DriverCallRequest, opts ...grpc.CallOption) (*DriverCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DriverCallResponse)
	err := c.cc.Invoke(ctx, ExporterService_DriverCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exporterServiceClient) StreamingDriverCall(ctx context.Context, in *StreamingDriverCallRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingDriverCallResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ExporterService_ServiceDesc.Streams[0], ExporterService_StreamingDriverCall_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamingDriverCallRequest, StreamingDriverCallResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExporterService_StreamingDriverCallClient = grpc.ServerStreamingClient[StreamingDriverCallResponse]

func (c *exporterServiceClient) LogStream(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ExporterService_ServiceDesc.Streams[1], ExporterService_LogStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, LogStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExporterService_LogStreamClient = grpc.ServerStreamingClient[LogStreamResponse]

func (c *exporterServiceClient) Reset(ctx context.Context, in *ResetRequest, opts ...grpc.CallOption) (*ResetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetResponse)
	err := c.cc.Invoke(ctx, ExporterService_Reset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exporterServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, ExporterService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *exporterServiceClient) EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndSessionResponse)
	err := c.cc.Invoke(ctx, ExporterService_EndSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExporterServiceServer is the server API for ExporterService service.
// All implementations must embed UnimplementedExporterServiceServer
// for forward compatibility.
//
// A service a exporter can share locally to be used without a server
// Channel/Call credentials are used to authenticate the client, and routing to the right exporter
type ExporterServiceServer interface {
	// Exporter registration
	GetReport(context.Context, *emptypb.Empty) (*GetReportResponse, error)
	DriverCall(context.Context, *DriverCallRequest) (*DriverCallResponse, error)
	StreamingDriverCall(*StreamingDriverCallRequest, grpc.ServerStreamingServer[StreamingDriverCallResponse]) error
	LogStream(*emptypb.Empty, grpc.ServerStreamingServer[LogStreamResponse]) error
	Reset(context.Context, *ResetRequest) (*ResetResponse, error)
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// End the current session, triggering the afterLease hook
	// The client should keep the connection open to receive hook logs via LogStream
	// Returns after the afterLease hook completes
	EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error)
	mustEmbedUnimplementedExporterServiceServer()
}

// UnimplementedExporterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExporterServiceServer struct{}

func (UnimplementedExporterServiceServer) GetReport(context.Context, *emptypb.Empty) (*GetReportResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetReport not implemented")
}
func (UnimplementedExporterServiceServer) DriverCall(context.Context, *DriverCallRequest) (*DriverCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DriverCall not implemented")
}
func (UnimplementedExporterServiceServer) StreamingDriverCall(*StreamingDriverCallRequest, grpc.ServerStreamingServer[StreamingDriverCallResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamingDriverCall not implemented")
}
func (UnimplementedExporterServiceServer) LogStream(*emptypb.Empty, grpc.ServerStreamingServer[LogStreamResponse]) error {
	return status.Error(codes.Unimplemented, "method LogStream not implemented")
}
func (UnimplementedExporterServiceServer) Reset(context.Context, *ResetRequest) (*ResetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedExporterServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedExporterServiceServer) EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EndSession not implemented")
}
func (UnimplementedExporterServiceServer) mustEmbedUnimplementedExporterServiceServer() {}
func (UnimplementedExporterServiceServer) testEmbeddedByValue()                         {}

// UnsafeExporterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExporterServiceServer will
// result in compilation errors.
type UnsafeExporterServiceServer interface {
	mustEmbedUnimplementedExporterServiceServer()
}

func RegisterExporterServiceServer(s grpc.ServiceRegistrar, srv ExporterServiceServer) {
	// If the following call panics, it indicates UnimplementedExporterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExporterService_ServiceDesc, srv)
}

func _ExporterService_GetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExporterServiceServer).GetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExporterService_GetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExporterServiceServer).GetReport(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExporterService_DriverCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DriverCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExporterServiceServer).DriverCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExporterService_DriverCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExporterServiceServer).DriverCall(ctx, req.(*DriverCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExporterService_StreamingDriverCall_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamingDriverCallRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExporterServiceServer).StreamingDriverCall(m, &grpc.GenericServerStream[StreamingDriverCallRequest, StreamingDriverCallResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExporterService_StreamingDriverCallServer = grpc.ServerStreamingServer[StreamingDriverCallResponse]

func _ExporterService_LogStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExporterServiceServer).LogStream(m, &grpc.GenericServerStream[emptypb.Empty, LogStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ExporterService_LogStreamServer = grpc.ServerStreamingServer[LogStreamResponse]

func _ExporterService_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExporterServiceServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExporterService_Reset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExporterServiceServer).Reset(ctx, req.(*ResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExporterService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExporterServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExporterService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExporterServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExporterService_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExporterServiceServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExporterService_EndSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExporterServiceServer).EndSession(ctx, req.(*EndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExporterService_ServiceDesc is the grpc.ServiceDesc for ExporterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExporterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jumpstarter.v1.ExporterService",
	HandlerType: (*ExporterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReport",
			Handler:    _ExporterService_GetReport_Handler,
		},
		{
			MethodName: "DriverCall",
			Handler:    _ExporterService_DriverCall_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _ExporterService_Reset_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _ExporterService_GetStatus_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _ExporterService_EndSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingDriverCall",
			Handler:       _ExporterService_StreamingDriverCall_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "LogStream",
			Handler:       _ExporterService_LogStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "jumpstarter/v1/jumpstarter.proto",
}
